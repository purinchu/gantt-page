<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<title>Project Gantt generator</title>
<style>
html,body {
    width: 100%;
    height: 100%;
    margin: 0px;
}

div#content {
    display: grid;
    grid-template-columns: 1fr 2fr;
    grid-gap: 10px;

}

div#errorOutput {
    font-family: monospace;
    color: red;
    background: white;
}

.chart {
    font-size: 12px;
}

.axis path,.axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
}

.bar {
    fill: darkred;
}

.bar-failed {
    fill: #CC0000;
}

.bar-running {
    fill: #669900;
}

.bar-succeeded {
    fill: #33b5e5;
}

.bar-killed {
    fill: #ffbb33;
}
</style>
</head>
<body>
    <h3>Gantt Viewer</h3>

    <div id="errorOutput"></div>
    <div id="content">
        <div id="input_wrapper">
            <textarea cols="50" rows="50" id="task_input">
# Use this "#" character to start a comment that the program ignores

# Opens up a new group of tasks
-- Major Group 1 --

# Tasks follow: "name" from "start date" to "end date"
RMF Step 5 from 2018-04-02 to 2018-04-12
A Job from 2018-05-01 to 2018-05-30

# Add dependencies here: "later task" depends on "earlier task"
A Job depends on RMF Step 5
            </textarea>
            <button id="btn_load_tasks">Load Tasks into Chart</button>
        </div>

        <div id="gantt_wrapper"></div>
    </div>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="gantt.js"></script>

    <script>

let btnLoadTasks = document.getElementById('btn_load_tasks');

btnLoadTasks.addEventListener('click', (ev) => {
    let inputArea = document.getElementById('task_input');
    const taskInput = inputArea.value;

    console.log("Loading gantt chart with " + taskInput);
    let errorOut = document.getElementById('errorOutput');
    errorOut.textContent = '';

    try {
        const [tasks, depNames] = parseTasks(taskInput);
        const deps = resolveDeps(tasks, depNames);

        setupGanttChart(tasks);
    }
    catch (e) {
        console.dir(e);
        errorOut.textContent = e.toString();
    }
});

function taskFromInputLine(line) {
    // line must be .trim()'d already for regex to work right

    // Look for dependency (syntax 1)
    const line_re = /([a-zA-Z0-9_ ]+) [fF]rom (2[0-9]{3}-[0-1]?[0-9]-[0-3]?[0-9]) [tT]o (2[0-9]{3}-[0-1]?[0-9]-[0-3]?[0-9])$/;

    let result = line_re.exec(line);
    if (result) {
        return {
            startDate: new Date(result[2]),
            endDate  : new Date(result[3]),
            taskName : result[1].trim(),
            deps     : [ ],
            status   : "TASK"
        };
    }

    // Look for dependency with duration (syntax 2)
    const task_dep_re = /([a-zA-Z0-9_ ]+) [tT]akes ([0-9]+) days?$/;
    result = task_dep_re.exec(line);
    if (result) {
        return {
            startDate: null,
            endDate  : null,
            duration : +(result[2].trim()),
            taskName : result[1].trim(),
            deps     : [ ],
            status   : "TASK"
        }
    }

    // Look for header line
    result = /^--+\s*(.*)\s*--+$/.exec(line);
    if (result) {
        return {
            startDate: new Date(2037, 12, 31),
            endDate  : new Date(1970, 0, 1),
            taskName : result[1].trim(),
            deps     : [ ],
            status   : "HEADER"
        }
    }

    // Look for dependency declaration
    result = /^([a-zA-Z0-9_ ]+)\s*(?:[Dd]epends on|[Nn]eeds)\s([a-zA-Z0-9_ ]+)$/.exec(line);
    if (result) {
        console.log(`Adding ${result[2]} as a dependency of ${result[1]}`);
        return {
            requiringTaskName: result[1].trim(),
            requiredTaskName:  result[2].trim(),
            status   : "DEPS"
        }
    }

    return null;
}

function resolveDeps(tasks, deps) {
    let taskNames = new Map();  // Maps task name to task

    tasks.forEach(t => taskNames.set(t.taskName, t));

    if (!deps.every(dep => taskNames.has(dep.requiredTaskName) && taskNames.has(dep.requiringTaskName)))
    {
        let missingTasks = deps
            .filter(dep => !taskNames.has(dep.requiredTaskName) || !taskNames.has(dep.requiringTaskName))
            .map(brokenDep => [brokenDep.requiringTaskName, brokenDep.requiredTaskName])
            .reduce((acc, task) => acc.concat(task), []);
        throw new Error("Missing tasks " + missingTasks.join(', '));
    }

    // Converts wordy dependency spec into array with a dependency edge
    return deps.map((dep) => {
        return [
            taskNames.get(dep.requiringTaskName), taskNames.get(dep.requiredTaskName)
        ];
    });
}

function parseTasks(taskInput) {
    let tasks = [];
    let deps  = [];
    var curHeader;

    const lines = taskInput.trim()
        .split(/\n+/)
        .map(str => str.replace(/#.*$/, '').trim())
        .filter(str => str.length > 0);

    for (const line of lines) {
        const task = taskFromInputLine(line.trim());

        if (task) {
            if (task.status === "HEADER") {
                // New header
                curHeader = task;
            }
            else if (task.status === "DEPS") {
                deps.push(task);
                continue;
            }
            else if (curHeader) {
                task.header = curHeader;
                curHeader.startDate =
                    (task.startDate.getTime() < curHeader.startDate.getTime())
                        ? task.startDate
                        : curHeader.startDate;
                curHeader.endDate =
                    (task.endDate.getTime() > curHeader.endDate.getTime())
                        ? task.endDate
                        : curHeader.endDate;
            }

            tasks.push(task);
        } else {
            throw "Invalid task " + line + "!";
        }
    }

    return [tasks, deps];
}

let gantt;

function setupGanttChart(tasks) {
    // Maps task statuses to CSS class names
    const taskStatus = {
        "HEADER" : "bar",
        "FAILED" : "bar-failed",
        "TASK" : "bar-running",
        "KILLED" : "bar-killed"
    };

    const taskNames = [ ...(new Set(tasks.map((x) => x.taskName))) ];

    if (!gantt) {
        gantt = d3.gantt()
            .taskTypes(taskNames)
            .taskStatus(taskStatus)
            .tickFormat("%b (%V)");
        gantt(tasks);
    }
    else {
        gantt.taskTypes(taskNames)
            .redraw(tasks);
    }
}
    </script>
</body></html>
